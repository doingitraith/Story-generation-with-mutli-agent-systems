\chapter{Implementation} % 25 pages
The following chapter describes the prototype game I created as part of this thesis. I explain how I applied the concepts and research introduced in the previous chapter.\\
The game simulates a small medieval kingdom and its inhabitants. The player controls a knight who is sent on a quest by the queen. The king is missing and the player shall return the king to the castle. The player can move around and interact with non-player characters (NPCs) and some key items. First I will introduce the \textit{Information Model}, that I created to define information in the game. Then I will go into detail about the \textit{agents}, that inhabit and exist in the game world. After that, I will describe the \textit{game world} itself followed by a \textit{gameplay} description. Then I will focus on the \textit{dialogue feature} and how information can be retrieved and introduced into the system. Following that I will give an explanation of how narrative is introduced using \textit{quests}. Additionally, I will provide the concrete implementations of both the information \textit{heuristic} and the \textit{consensus protocol}. The chapter will be closed off, by discussing the \textit{narrative implications} of the described gameplay.
\section{Technology}
Before I go into detail about the game logic, I want to explain my choice of development environment. For the prototype game I chose the Unity engine developed by Unity Technologies~\cite{Unity2021}. This choice was made because I have multiple years of experience with the Unity engine and it allows for fast prototyping that is easy to iterate upon. Unity is widely used across the video game industry, has an active developer community and is well documented. The programming language for Unity is Microsoft C\# with the .NET framework, which I have also many years of experience with. All assets that are used in the prototype game are either purchased or free to use. All asset creators are properly credited in the prototype.
\section{Information Model}
At the center of the game mechanic created for this thesis, is the \textit{Information Model}. I propose a conceptional model for information objects that encapsulate statements about semantic and factual game world data (see \ref{section:info}). The statements encapsulated in an \verb|Information| object is primarily characterized by its \textit{Verb}. The verb is the main indicator of the assertion of the information content. Every information object also contains a \textit{Subject} which denotes who or what the information statement is concerned with. The third part of the information is dependent on the verb and can either be an \textit{Object}, an \textit{Adjective} or a \textit{Location}.
Thus every information object $I$ consists of a triple of information elements:
\begin{center}
	$I \coloneqq \{s, v, x\}$ 
\end{center}
Where $s$ is the subject, $v$ is the verb and $x \in \{\textit{Object, Adjective, Location}\}$ depending on the verb. Figure~\ref{fig:informationCD} shows the class diagram for the \verb|Information| class. Although the elements of an \verb|Information| object refer to actual game objects in the game world, this link is purposely severed when an \verb|Information| object is created. This is done, so that the information statement is actually just that and has no exploitable connection to other objects anymore. Thus the \textit{Information Model} and the programming interface remain decoupled which allows for a more accurate simulation.\\
The \verb|Information| class also implements the \verb|IMutatable| interface which only declares the function \verb|Mutate|. This function should reduce the accuracy in the statement by reducing the accuracy in any of the statement components every time it is called.
\begin{figure}
	\centering
	\includegraphics[width=0.3\textwidth]{InformationCD}
	\caption{Inheritance diagram of the Information class}
	\label{fig:informationCD}
\end{figure}
\subsection{Verbs}
Verbs in the \textit{Information Model} come in three types:
\begin{itemize}
	\item \textbf{IS}: Creates information statements about the \textit{state} of a subject of the form "\textit{Subject} \verb|IS| \textit{Adjective}".
	\item \textbf{HAS}: Creates information statements about a possessive relationship between subject and object of the form "\textit{Subject} \verb|HAS| \textit{Object}".
	\item \textbf{AT}: Creates information statements indicating the location of a subject of the form "\textit{Subject} \verb|AT| \textit{Location}". The \verb|AT| type presents a special form of the \verb|IS| type, but in the context of a traversable 3D world, locations represents such an important piece of state, that its own information type is justified.
\end{itemize}
\textit{Verbs} are instances of the \verb|Verb| enumeration. The constructors in the \verb|Information| class are designed in such a way, that the verb is set by the constructor and there exist multiple overloads to create the different types of information objects (Listing \ref{listing:information}).
\begin{lstlisting}[
	caption={Information class constructors},
	label={listing:information}
	]
	public Information(Agent agent, Item object)
		=> (Subject, Verb, Object, Adjective, Location, Not) =
		(agent.InformationSubject, InformationVerb.Has, object.InformationSubject, null, null, false);
	
	public Information(WorldObject subject, InformationAdjective informationAdjective)
		=> (Subject, Verb, Object, Adjective, Location, Not) =
		(subject.InformationSubject, InformationVerb.Is, null, informationAdjective, null, false);
	
	public Information(WorldObject subject, InformationLocation informationLocation)
		=> (Subject, Verb, Object, Adjective, Location, Not) =
		(subject.InformationSubject, InformationVerb.At, null, null, informationLocation, false);
\end{lstlisting}
This way \verb|Information| objects can be created with only the content in mind, and the constructor sets up the object correctly for usage.
\subsection{Subjects}
As mentioned, every piece of information contains a \textit{subject}. They represent the concerning entity of an information statement. A \textit{subject} is an instance of the \verb|InformationSubject| class that conceptually either represents an \verb|Agent| or an \verb|Item|, both of which inherit from the \verb|WorldObject| class.\\
What exact type of object a \textit{subject} is in a given \verb|Information| object, is again dependent on the \textit{verb}. For example there can be no information of the form "\textit{Item} \verb|HAS| \textit{Agent}" because an item cannot own an agent. The constructors for \verb|Information| objects make sure that no erroneous object can be created.\\
\textit{Subjects} consist  of a textual name that denotes the \textit{subject} and two boolean values that state whether the \textit{subject} is an agent or not and whether it is a unique object, which is important for items (Figure~\ref{fig:subjectCD}).
\begin{figure}
	\centering
	\includegraphics[width=0.6\textwidth]{SubjectCD}
	\caption{Inheritance diagram of the InformationSubject class}
	\label{fig:subjectCD}
\end{figure}
\textit{Subjects} also have a \verb|Mutation| object attached that is responsible for decaying the accuracy of the \textit{subject}. I give a detailed explanation of mutations in Section~\ref{section:mutation}.
\subsection{Adjectives}
An \textit{adjective} represents a detail or characteristic of a \textit{subject's} state. The can be arbitrarily defined by a developer. They represent the properties of a \textit{subject}. \textit{Adjectives} are instances of the \verb|InformationAdjective| class (Figure~\ref{fig:adjectiveCD}). In the \textit{Information Model} there are two differentiable types of \verb|InformationAdjective| objects:
\begin{itemize}
	\item \verb|InformationProperty|: Represents factual information about a \textit{subject}. For example "\textit{Agent} \verb|IS| \textit{alive}." is a factual piece of information that can be either true or false.
	\item \verb|InformationOpinion|: Represents statements about a \textit{subject's} state that are influenced by information holder's relationship to the \textit{subject}. For example the statement "\textit{Agent} \verb|IS| \textit{dangerous}." can be true for one agent but false for another.
\end{itemize}
This distinction is introduced so that conceptually there can be a difference between facts and opinions that someone has about any \textit{subject}.\\â€¢
An \verb|InformationAdjective| consists of the textual \textit{Characteristic} and a list of \textit{contradictions}. The contradictions are other \textit{adjectives} that are conflicting with the \textit{adjective} they are attached to. A simple example would be the two information statements  "\textit{Agent} \verb|IS| \textit{alive}." and  "\textit{Agent} \verb|IS| \textit{dead}.". Both cannot be true at the same time. Therefore, each \textit{adjective's} contradictions list contains the respective other. When an agent learns a new information that contains an \textit{adjective}, they check the \textit{adjective's} contradictions and resolve any conflicts.\\
At the start of the game, an initial list of \textit{adjectives} that exist in the world is created. After that, the contradictions lists are created and attached to each \textit{adjective}.
\begin{figure}
	\centering
	\includegraphics[width=0.8\textwidth]{AdjectiveCD}
	\caption{Inheritance diagram of the InformationAdjective class}
	\label{fig:adjectiveCD}
\end{figure}
\subsection{Locations}
As mentioned before, a \textit{location} is a special kind of \textit{object} for the \verb|AT| information type. In a 3D game world that is driven by a multi-agent system, agents need to move around. For that the \verb|InformationLocation| class attaches a position in the world to the information so that agents can retrieve an actual location from the information statement.\\
A \textit{location} also has a \verb|Mutation| object attached to it, so its accuracy can be reduced. Other than that, the \verb|InformationLocation| has only a textual name and the 3D position as a public interface.
\begin{figure}
	\centering
	\includegraphics[width=0.6\textwidth]{LocationCD}
	\caption{Inheritance diagram of the InformationLocation class}
	\label{fig:locationCD}
\end{figure}
\subsection{Mutation}
\label{section:mutation}
To simulate the decay of information and agents forgetting details, the \textit{Information Model} implements a \textit{Mutation} functionality. \verb|InformationSubject| and \verb|InformationLocation| objects have an object of the \verb|Mutation| class. These represent a hierarchy of less precise information values. Every \verb|Mutation| object has a reference \verb|ParentMutation| that points to a \verb|Mutation| object that holds the next less precise information value.\\
As an example, we assume the \verb|InformationLocation| $l$ with the name value "\textit{Village Square}". The \verb|Mutation| object can point to a less precise information value "\textit{Village}" which in turn points to an information value "\textit{Somewher in the South}". This way when $l$ is mutated once, its name value will be "\textit{Village}" and if mutated again will decay to "\textit{Somewhere in the South}" where it will remain.\\
This mechanic allows for agents to slowly forget about details in their information statements which makes the collection of memories more chaotic over time.\\
The values for the mutation hierarchy are set by the developer before the game starts.\\
The \verb|Mutate| function in the \verb|Information| class that is provided by the \verb|IMutatable| interface triggers the mutation of any of its statements' components.
\section{Agents}
In any multi-agent system, the central component are of course the agents. In the prototype game, those agents represent the NPCs who live in the game world or the player (Figure~\ref{fig:agentCD}). The only difference is that the player agent is controlled by the player instead of the game. But for the NPCs, there is no difference between the player agent or any other NPC. In the following I will generally talk about NPCs as agents for better understanding of the conceptual implications in a multi-agent system. Agents move around in the world to perform actions, exchange information and change their state depending on what they learn.
\begin{figure}
	\centering
	\includegraphics[width=0.6\textwidth]{AgentCD}
	\caption{Inheritance diagram of the Agent class}
	\label{fig:agentCD}
\end{figure}
The \verb|WorldObject| class is the parent class for both \verb|Agent| and \verb|Item| classes. I represents physical entities that exist as part of the multi-agent system. \verb|WorldObject| itself is a child class of Unity's \verb|MonoBehaviour| class which is the base class of all game objects managed by the Unity engine.\\
All \verb|Agent| instances inherit the members of their parent classes and thus have a textual identifier \textit{Name}, a \textit{Location} to denote the object's current location, exposed properties to set up the \textit{InformationSubject} and an integer value \textit{WorldImportance}. This value is important for the information heuristic for believability which is described in section %TODO add ref to heuristic.
\textit{WorldImportance} indicates the initial interest a piece of information gets through the involved object. This interest can be positive or negative. A piece of information about the castle might have high positive value, since the castle is an important place in the kingdom. Information about an enemy bandit however, will have a negative number, as people are afraid of the bandits. These values should be an objective measure of an object's interest value. Subjective views from the agents are taken into account when the heuristic is calculated.\\
The important properties of the \verb|Agent| class are the \textit{Inventory} which stores items in the agent's possession, \textit{Acquaintances} contains other agents that have interacted with the object, \textit{ImportantPeople} are agents that have a close relationship with the object like friends or loved ones and \textit{Quests} which is a list of objectives the agent has. Through the \textit{ImportantPeople} property, certain agents can be treated differently and more favorably than others. This allows the introduction of a social network component into the multi-agent system.\\
The boolean values \textit{IsSeeing} and \textit{IsHearing} allow to determine what kind of information the agent is able to "sense" respectively.\\
The heart of the game mechanic is the \textit{Memory} property. It is an \verb|InformationManager| object. As the name implies, it stores, processes and manages all the incoming pieces of information.\\
The different actions an agent can execute are also defined here. This includes interacting with other agents, picking up and dropping items or attacking agents.
\subsection{NPC}
The \verb|NPC| class is a child class of the \verb|Agent| class and defines additional properties and functions that are unique only for NPCs.\\
This includes a \textit{Routine} property which is a list of behaviors the agent will execute one after another to simulate a daily life of a human. When they reached the end of their routine, they will start again from the beginning.
\subsection{Player}
In the scope of this thesis the \verb|Player| class behaves very similar to other agents. It has components attached that enable input to control the player agent. It needs its own class, so that developers can differentiate between NPCs and the player. This is necessary as the agents don't might want to behave differently when interacting with the player agent to expose more information to the actual player in front of the screen. For example when a dialogue is started, an NPC will not simply send information and continue with its routine, but it will pause and the dialogue interface will be opened where the information exchanged is controlled by the player.
\subsection{Behavior}
In order for the intelligent agents to move, interact and follow their objectives, I defined multiple behaviors that allow them to perform actions (Figure~\ref{fig:behaviorCD}). The following behavior classes exist:
\begin{itemize}
	\item \verb|ExchangeInformationBehavior|: This behavior allows two agents to engage in an exchange a piece of information. They choose which information to send each other based on the information heuristic.
	\item \verb|SendInformationBehavior|: As a child class of \verb|ExchangeInformationBehavior|, this behavior selects a random agents from the list oof \textit{ImprotantPeople} and sends them a piece of information also based on the information heuristic. This behavior can be interpreted as "sending a message" to a distant friend. I implemented this so that information would also reach farther parts of the world eventually.
	\item \verb|WalkBehavior|: This simply allows the agent to move to a specified location in the world.
	\item \verb|TalkBehavor|: This would allow NPCs to stop the player and engage in a conversation with them. In the prototype game this behavior is never used and it is only the player who can initiate a  conversation.
	\item \verb|WaitBehavior|: To simulate NPCs that are waiting or "doing nothing" for a specified time, I implemented this behavior. It is mostly to make the simulated behavior look more realistic and have NPCs stand in a place for a while.
	\item \verb|PickUpBehavior| and \verb|DropBehavior|: These two are implemented to let NPCs pick up a specified item in the vicinity or drop it in font of them respectively.
\end{itemize}
\begin{figure}
	\centering
	\includegraphics[width=1.2\textwidth]{BehaviorCD}
	\caption{Inheritance diagram of the AgentBehavior class}
	\label{fig:behaviorCD}
\end{figure}
The parent \verb|AgentBehavior| class is an abstract class and declares functions for starting, interrupting and resuming a behavior. Additionally it declares the function \verb|IsBehaviorFinished| to check if the behavior is completed. This simple setup of behavior allows for easy extension of the capabilities of agents.
\subsection{Information Manager}
At the heart of the agents' logic is the \verb|InformationManager| class. It provides all the necessary functions to add, manage and process incoming \verb|Information| objects for an agent. Its main task are adding new pieces of information to the memory and evaluating them on a regular basis to update the information heuristic values.\\
It manages the different pieces of information with lists of \verb|InformationContext| objects. Those are objects that pack an \verb|Information| object with contextual data about how the information was received. The context object stores how many times the information was received already by distinct agents, who it was received from, the time since it was last received and current values for believability and information heuristic.\\
The \textit{Information Manager} provides two lists of \verb|InformationContext| objects to manage its memories:
\begin{itemize}
	\item \textit{Speculative Memory}: the speculative memory stores every piece of information that an agent receives. It is a list of unconfirmed information that needs to be evaluated before it can be trusted. Only information that the agent did not perceive itself but was given to it by others, is considered speculative.
	\item \textit{Stable Memory}: confirmed or trusted information is stored in the stable memory. Everything an agent learns by its own senses like seeing, hearing or otherwise witnessing goes directly to the stable memory. If information is received via another agent, it needs to be verified through believability before it is transferred from the speculative memory to the stable memory. When an agent evaluates the information stored in its memory, it also updates believability values for every piece of information. This value is closely tied to the information heuristic. If the believability of an information is above a certain threshold, it is transferred to the stable memory and if it falls under the threshold, it is sent back to the speculative memory.
\end{itemize}
This structure, of speculative and stable memory is taken from high availability backup systems. A process called chain replication uses a similar technique, where any change to the system is put into a speculative history until all nodes in the backup change have confirmed it. After that it is transferred through all nodes again, but in a stable history. When all nodes have confirmed the change in the stable history, the update was successful.~\cite{Van2004}\\
Although agents are only a single node, I tried to replicate this confirmation methodology with the speculative and stable memories.
\section{Game World}
The agents in the prototype game live in an environment. The environment in the prototype game is \textit{inaccessible}, \textit{deterministic}, \textit{static} and \textit{discrete}. It is inaccessible because agents learn of changes in the environment state only when they perceive or receive information about them, not as they happen. It is deterministic because every change an agents performs on the environment's state is known beforehand. The environment is static because the topology and and structure does not change in this prototype and it is discrete because the space agents can move in is limited.\\
In the prototype game, the environment for the multi-agent system is the game world. I created a 3D world that contains interesting and memorable locations that agents can move around in. I recreated a small kingdom with several settlements where different agents live and go about their day. The key locations are \textit{the village}, \textit{the castle}, \textit{the sawmill}, \textit{the forest}, \textit{the lake}, \textit{the farm} and \textit{the enemy camp}~\ref{fig:gameWorld}.
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{GameWorld}
	\caption{An overview of the game world.}
	\label{fig:gameWorld}
\end{figure}
The landscape is filled with paths and landmarks to make orientation easier and guide the player between the locations.\\
I chose a medieval kingdom for my environment since it is a well understood and established context for video game worlds. Ford in his work about medieval towns in single player games describes how the boundaries between village and nature are also boundaries between the home and the frontier, the old and the new, the familiar and the unknown. This does not only relate to classic narratives about heroes venturing out into the wild, but also says interesting things about this dichotomy in game worlds. Video games often contextualize towns and nature through their mechanics. There are games for examples where you cannot use your weapons while inside a town or city. They also very often serve as quest hubs or quest destinations. This means that the borders define on a mechanical level what the player is allowed to do. Much like with real-world definitions of borders, this might say more about the player and their position in the game world than it does about the city ot town itself.~\cite{Ford2019}
\section{Gameplay}
I have touched previously upon what the player interactions are that form the gameplay of the prototype game. Players control a knight in the kingdom who sets out to go on quests and adventures in the kingdom (Figure~\ref{fig:gameplay}). The player controls the movement of the knight and can talk to NPCs and interact with key items. If the player picks up a weapon, the character is able to attack other agents.\\
The novel game mechanic this prototype now presents and that is the topic of this thesis is more about the \textit{How} than the \textit{What}. Initially the player character is given a quest to return the king back to the castle. That is all the information the player is given who is now free to roam the game world to try and reach this goal.\\
Though talking to NPCs and learning new information about the world, the player can find clues that help them reach their goal. Where exactly is the king? Is he guarded by a monster? How can I defeat the monster? NPCs can give pieces of information that let the player step by step deduce an answer to this question.\\
Or the player can go a completely different route. By talking to NPCs they can introduce new or even wrong pieces of information into the world. Could I convince enough people that I am the king? And if someone would tell the queen, would she believe I am the king? And would that allow me to go back to the castle and thus achieve the goal?\\
The systems that I have created for this prototype allow for varied and interesting solutions to quests even for the little amount of content that is in the prototype.
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{Gameplay}
	\caption{A sample gameplay scene.}
	\label{fig:gameplay}
\end{figure}
\section{Dialogue}
The main way to purposely learn and give out information in the game is to talk to NPCs. For that I have created a dialogue system that let's you either receive a random information from a NPC, ask a specific question or make a  statement on your own.\\
I used Yarn Spinner from Secret Lab to create the dialogue~\cite{Secret2021}. It is a lightweight tool that comes with a Unity plug in and allows for branching node-based dialogue and supports variables and simple logic in its dialogue files.\\
Yarn Spinner comes with an editor that easily allows developers to set up and write complex and branching dialogue files.
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{Yarn}
	\caption{The NPC Yarn dialogue file}
	\label{fig:yarn}
\end{figure}
\subsection{Questions}
Allowing the player to ask questions about specific game objects is much more goal oriented that randomly hoping for useful information to happen upon the player. The dialogue interface allows the player to create questions from a question verb, an information verb and an object(Figure~\ref{fig:question}). The question verbs \textit{Who}, \textit{What}, \textit{Where} and \textit{How} indicate whether the expected answer will be a NPC name, an item, a location or an adjective. The question object contains options depending on the selection of question verb and information verb. If the NPC has an information that matches the question requirements, it will tell it to the player.
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{Question}
	\caption{Posing a statement to an NPC.}
	\label{fig:question}
\end{figure}
\subsection{Statements}
This allows the player to create new information based on object they have encountered while playing. In the dialogue interface, the player can create information statements like they are defined in the \textit{Information Model}(Figure~\ref{fig:statement}). The selected verb will define what options are available for information subject and information object. The available subjects and objects depend on the NPCs, items and locations, the player has encountered so far. Only adjectives are universally known by all agents as they do not represent things in the world but rather concepts.\\
If the information statement is well-formed according to the \textit{Information Model}, the newly created information will be transmitted to the NPC as if any other agent would have told to it.\\
The functionality to create any information from known components creates the ability to lie for the player which creates interesting gameplay implications.
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{Statement}
	\caption{Asking a question to a NPC.}
	\label{fig:statement}
\end{figure}
\section{Inference}
To simulate the flow and creation of information more realistically in the NPCs, they can also deduce new Information from the ones they have. These deductions are based on rules that are globally defined and represent a form of cohesive causal understanding of the game world. To define such rules, there is the \verb|InferenceRule| class. It consists of a \verb|BoolExpression| object that defines the rule and a list of \verb|Information| objects that define the consequences or outcomes if the rule applies.\\
The \verb|BoolExpression| object holds \verb|Information| objects and is chained together with other \verb|BoolExpression| objects by logical operators to create the rule. Listing~\ref{listing:rule} defines the following rule for any agent $X$:
\begin{center}
	\textit{isArmed}$(X) \wedge $ \textit{isEnemy}$(X) \Rightarrow $ \textit{isDangerous}$(X)$ 
\end{center}
\begin{lstlisting}[
	caption={Creating an inference rule with consequences},
	label={listing:rule}
	]
	var rule = new InferenceRule(new BoolExpression(new Information(_player, WorldAdjectives[Adjectives.Armed]))).And(new BoolExpression(new Information(_player, WorldAdjectives[Adjectives.Enemy])));

	rule.Consequences = new List<Information> { new Information(_player, WorldAdjectives[Adjectives.Dangerous]) };
\end{lstlisting}
The variable \verb|_player| in the statement is just a placeholder and is replaced with different subjects during evaluation of the rule. For the scope of this thesis it made only sense to substitute for information subjects, since the \textit{Information Model} is structured in such a way, that the information statements say something about an information subject.\\
In order to evaluate such a rule, every agent has an \textit{Inference Engine} that allows them to to so. The \textit{Inference Engine} sees the agent's stable memories as its knowledge base. It goes through the rules and checks if the knowledge base of the agent satisfies the rule. If so, all the pieces of information that are defined in a rules's list of consequences is added to the stable memory of the agent(Listing~\ref{listing:evaluate}). This is repeated until no new information is added, since any new information could trigger another rule.\\
The \verb|SatisfiesKnowledgeBase| function recursively checks if a rule's \textit{Boolean Expression} applies to the agent's memories. A information's subject is selected as a candidate if the information matches the information in the \textit{Boolean Expression} in all components except for the subject.
\begin{lstlisting}[
	caption={Evaluating inference rules},
	label={listing:evaluate}
	]
	public void Evaluate(){
		foreach (InferenceRule rule in Rules){
			List<InformationSubject> candidates = SatisfiesKnowledgeBase(rule.Expression, new List<InformationSubject>());
			
			if (!rule.AppliesToSelf)
				candidates.Remove(KnowledgeBase.Owner.InformationSubject);
			
			if (candidates.Any()){
				candidates.ForEach(c =>{
					rule.Consequences.ForEach(r =>{
						r = new Information(c, r);
						KnowledgeBase.TryAddNewInformation(r, KnowledgeBase.Owner);
					});
				});
				Evaluate();
			}
		}
	}
\end{lstlisting}
This way agents can "reflect" on what they know and deduce new information.
\section{Heuristic}
% Heuristic 2
Each agent is able to subjectively evaluate the believability of pieces of information it has stored in its memory. A metric is needed to measure the believability of information. I approached this via the "interest" of an information. This means how special is a piece of information or how probable is it that a give information could be true. This depends on the "interest" of the involved information components. The information "\textit{Farmer} \verb|HAS| \textit{milk}" is much more probable or uninteresting" than the information "\textit{The king} \verb|HAS| \textit{the magical sword}". So by evaluating the components of the information and their relation to one another, a value for the "interestingness" of an information is calculated. I call this value \textit{Information Heuristic}.\\
The calculations for the \textit{Information Heuristic} are of course slightly different depending on types of the involved information components. The general idea is that the more "interesting" an information is, the higher its \textit{Information Heuristic} is. To make this value subjective to the agent, values that depend on the agent's experience or relation to involved agents is are taken into consideration.\\
The basic formula is as follows:
\begin{equation}
	h = h\ h'\ b\ n_i\sum_{a \in K}trust(a)
\end{equation}
with $K \coloneqq \{A \cap I\}$, where $A$ is the set of known associates of the agent and $I$ is the set of agents this information was previously received from.\\
The value $h'$ is the part of the heuristic that is dependent on the verb and the information components, $b$ is the previous believability of the information and $n_i$ is the number of times this information has already been received.\\
In other words, an information's heuristic is the product of itself with the component-dependent heuristic, the believability, the number of times it has been received and the sum of the trust values of known agents this information has been received from. \\
Now the component-dependent heuristic is another calculation heavy function. It differentiates between the verb and then in each case calculates the value differently depending on the components. If another agent is involved for example, the distance or degrees of separation between the bespoke agent and the receiver of the information is taken into account. The calculation is done using breadth-first search. This should reflect cases where information is received like "I heard from a friend of a friend...". The longer the distance, the less trustworthy the information. If the subject is a known associate, then the trust the agent has towards the subject is also considered. The number of other pieces of information the receiver has, concerning the subject is also used. This should reflect a familiarity with the subject.\\
If the subject of the information is an item, then not only is the uniqueness of the item in world relevant but also how unique the item is for the agent. This takes into account, whether the agent owns an item of the same type and how many other pieces of information it has that refer to an item of the same type. This again is to simulate how familiar the agent is with the bespoke item.\\
So now there is a value for every information an agent has, that says how "interesting" or "probable" that information is. To calculate the believability of an information, this heuristic is now put into context with every other information an agent has. I define the \textit{distance} between two pieces of information as the absolute difference between their heuristic values.\\
For the believability $b$ of a piece of information this results in:
\begin{equation}
	b = \frac{\sum_{i,j \in M, i \neq j} h(i)-h(j)}{n}
\end{equation}
In this formula, $n$ is the size of the stable memory and $M$ is the stable memory itself. The function $h$ is the heuristic function. This means the believability of an information is the average distance to every other information in the stable memory.\\
Since this is calculated for every information in the stable memory of every agent, this operation needs a lot of processing power. I implemented the MapReduce programming model to enable the distribution of these calculations. The prototype does not leverage the distribution itself since this was too big a task for the scope of the thesis, but the implementation is prepared to be used with little additional work (Listing~\ref{listing:map}). The \textit{Map} and \textit{Reduce} steps are marked with comments in the listing.
\begin{lstlisting}[
	caption={The MapReduce implementation for calculating believability},
	label={listing:map}
	]
public void UpdateBelievability(){
	List<InformationContext> data = GetAllMemories();
	
	// Map
	var distances = new List<List<float>>();
	
	for (int i = 0; i < data.Count; i++){
		distances.Add(new List<float>());
		for (int k = 0; k < data.Count; k++){
			Information i1 = data[i].Information;
			Information i2 = data[k].Information;
			if (!i1.Equals(i2))
				distances[i].Add(GetInformationDistance(i1, i2));
		}
	}
	
	// Reduce
	for (int i = 0; i < distances.Count; i++){
		if (ContainsStableInformation(data[i].Information) && distances[i].Any())
			GetStableMemory(data[i].Information).Believability = distances[i].Average();
		else if (ContainsSpeculativeInformation(data[i].Information) && distances[i].Any())
			GetSpeculativeMemory(data[i].Information).Believability = distances[i].Average();
	}
}
\end{lstlisting}
Just how expensive the call to the \verb|UpdateBelievability| function is can be measured with Unity's \textit{Profiler}. It is a tool, that allows detailed time measurements of the different function calls in the Unity engine (Figure~\ref{fig:profiler}). The blue spikes in Figure~\ref{fig:frame} show spikes in the calculation times when the function is called.\\
The frame is data was captured about two minutes after game start. By this time all the agents have moved around for a while and learned new information. The function call takes 92ms. Almost a second of calculation time is an immense performance issue.\\
The function call is also perceivable in the game as there is a noticeable frame drop when the believability is calculated. This shows that distributing the call by truly applying the MapReduce model and using multiple nodes to calculate the believability would be a worthwhile adaption of the prototype. The amount of time this takes is not so important if it does not halt the game as a simulation of the human process of "reflecting on one's thoughts" is something that could actually profit from a little waiting time.
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{Profiler}
	\caption{Frame data of the UpdateBelievability function call.}
	\label{fig:profiler}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{Frame}
	\caption{UpdateBelievability function call time.}
	\label{fig:frame}
\end{figure}
\section{Consensus}
% Consensus 2
\section{Quests}
To give the player an objective and an incentive to take action in this game, quests can be created. They have associated lists of information pieces and inference rules. For a quest to be completed either the quest giver has to know about the required quest information or the required inference rules have to satisfy the knowledge base of the quest giver.\\
That makes the quest state completely subjective to the quest giver. Rather than being managed globally by a \textit{Game Manager}, the quest is solely dependent on the \textit{Information Manager} of the quest giver.\\
In the scope of the prototype game, I have created one quest that is available to complete. At the start of the game, when talking to the queen in the castle, she will task the player with returning the king to the castle (Figure~\ref{fig:quest}). This requirement can be created with one inference rule (Listing~\ref{listing:quest}).
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{Quest}
	\caption{A quest is presented to the player.}
	\label{fig:quest}
\end{figure}
\begin{lstlisting}[
	caption={Creating an inference rule for a quest},
	label={listing:quest}
	]
	var rule = new InferenceRule(new BoolExpression(new Information(_player, WorldAdjectives[Adjectives.King]))).And(new BoolExpression(new Information(_player, GameObject.Find("Castle").GetComponent<Location>())));
	
	Quest q = new Quest(GameObject.Find("Queen").GetComponent<NPC>());
	q.GoalRules.Add(rule);
\end{lstlisting}
The rules simply defines two requirements: Any character who \textit{is} the king and who is \textit{at} the castle at the castle at the same time, will satisfy this rule. This creates \textit{objective-oriented} quests following Aarseth's classification~\cite{Aarseth2005}. There are only goal requirements that define the quest, all the steps to achieve this goal are up to the player. Combined with the dialogue system, this systems allows however, to create also more controlled quests. Dialogue can play out differently based on variables that can be set depending on what the player does in the world. Additional inference rules could be added that cover different outcomes for the quest. Quest giver characters could then react differently to those outcomes. The quest system is flexible to allow varied gameplay approaches through defining only goal requirements, but allowing developers to take a more narrated approach by providing additional narration for specific combinations of outcomes.
\section{Narrative}
% Narrative