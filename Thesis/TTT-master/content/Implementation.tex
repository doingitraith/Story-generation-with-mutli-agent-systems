\chapter{Implementation}
The following chapter describes the prototype game I created as part of this thesis. I explain how I applied the concepts and research introduced in the previous chapter.\\
The game simulates a small medieval kingdom and its inhabitants. The player controls a knight who is sent on a quest by the queen. The king is missing, and the player shall return the king to the castle. The player can move around and interact with non-player characters (NPCs) and some key items. First, I will introduce the \textit{Information Model} that I created to define information in the game. Then I will go into detail about the \textit{agents} that inhabit and exist in the game world. After that, I will describe the \textit{game world} itself, followed by a \textit{gameplay} description. Then I will focus on the \textit{dialogue feature} and how information can be retrieved and introduced into the system. Following that, I will give an explanation of how narrative is introduced using \textit{quests}. Additionally, I will provide the concrete implementations of both the information \textit{heuristic} and the \textit{consensus protocol}. The chapter will be closed off by discussing the \textit{narrative implications} of the described gameplay.
\section{Technology}
Before I go into detail about the game logic, I want to explain my choice of the development environment. For the prototype game, I chose the Unity engine developed by Unity Technologies~\cite{Unity2021}. This choice was made because I have multiple years of experience with the Unity engine, and it allows for fast prototyping that is easy to iterate. Unity is widely used across the video game industry, has an active developer community, and is well documented. The programming language for Unity is Microsoft C\# with the .NET framework, which I also have many years of experience with. All assets that are used in the prototype game are either purchased or free to use. All asset creators are credited adequately in the prototype. The project is available under the MIT license at \url{https://github.com/doingitraith/Story-generation-with-mutli-agent-systems}~\cite{prototype}.
\section{Information Model}
At the center of the game mechanic created for this thesis is the \textit{Information Model}. I propose a conceptional model for information objects that encapsulate statements about semantic and factual game world data (see \ref{section:info}). The statements encapsulated in an \verb|Information| object are primarily characterized by its \textit{Verb}. The verb is the primary indicator of the assertion of the information content. Every information object also contains a \textit{Subject} that denotes who or what the information statement is concerned with. The third part of the information is dependent on the verb and can either be an \textit{Object}, an \textit{Adjective}, or a \textit{Location}.
Thus every information object $I$ consists of a triple of information elements:
\begin{center}
	$I \coloneqq \{s, v, x\}$ 
\end{center}
Where $s$ is the subject, $v$ is the verb, and $x \in \{\textit{Object, Adjective, Location}\}$ depending on the verb. Figure~\ref{fig:informationCD} shows the class diagram for the \verb|Information| class. Although the elements of an \verb|Information| object refer to actual game objects in the game world, this link is purposely severed when an \verb|Information| object is created. This is done so that the information statement is actually just that and has no exploitable connection to other objects anymore. Thus the \textit{Information Model} and the programming interface remain decoupled, which allows for a more accurate simulation.\\
The \verb|Information| class also implements the \verb|IMutatable| interface, which only declares the function \verb|Mutate|. This function should reduce the accuracy in the statement by reducing the accuracy in any of the statement components every time it is called.
\begin{figure}
	\centering
	\includegraphics[width=0.3\textwidth]{InformationCD}
	\caption{Inheritance diagram of the Information class}
	\label{fig:informationCD}
\end{figure}
\subsection{Verbs}
Verbs in the \textit{Information Model} come in three types:
\begin{itemize}
	\item \textbf{IS}: Creates information statements about the \textit{state} of a subject of the form "\textit{Subject} \verb|IS| \textit{Adjective}".
	\item \textbf{HAS}: Creates information statements about a possessive relationship between subject and object of the form "\textit{Subject} \verb|HAS| \textit{Object}".
	\item \textbf{AT}: Creates information statements indicating the location of a subject of the form "\textit{Subject} \verb|AT| \textit{Location}". The \verb|AT| type presents a special form of the \verb|IS| type, but in the context of a traversable 3D world, locations represent such an important piece of state that its own information type is justified.
\end{itemize}
\textit{Verbs} are instances of the \verb|Verb| enumeration. The constructors in the \verb|Information| class are designed in such a way that the verb is set by the constructor, and there exist multiple overloads to create the different types of information objects (Listing \ref{listing:information}). This ensures that the developer cannot easily create invalid \verb|Information| instances.
\begin{lstlisting}[
	caption={Information class constructors},
	label={listing:information}
	]
	public Information(Agent agent, Item object)
		=> (Subject, Verb, Object, Adjective, Location, Not) =
		(agent.InformationSubject, InformationVerb.Has, object.InformationSubject, null, null, false);
	
	public Information(WorldObject subject, InformationAdjective informationAdjective)
		=> (Subject, Verb, Object, Adjective, Location, Not) =
		(subject.InformationSubject, InformationVerb.Is, null, informationAdjective, null, false);
	
	public Information(WorldObject subject, InformationLocation informationLocation)
		=> (Subject, Verb, Object, Adjective, Location, Not) =
		(subject.InformationSubject, InformationVerb.At, null, null, informationLocation, false);
\end{lstlisting}
This way, \verb|Information| objects can be created with only the content in mind, and the constructor sets up the object correctly for usage.
\subsection{Subjects}
As mentioned, every piece of information contains a \textit{subject}. They represent the concerning entity of an information statement. A \textit{subject} is an instance of the \verb|InformationSubject| class that conceptually either represents an \verb|Agent| or an \verb|Item|, both of which inherit from the \verb|WorldObject| class.\\
What exact type of object a \textit{subject} is in a given \verb|Information| object is again dependent on the \textit{verb}. For example, there can be no information of the form "\textit{Item} \verb|HAS| \textit{Agent}" because an item cannot own an agent. The constructors for \verb|Information| objects make sure that no erroneous object can be created.\\
\textit{Subjects} consist  of a name that denotes the \textit{subject} and two boolean values that state whether the \textit{subject} is an agent or not and whether it is a unique world object (Figure~\ref{fig:subjectCD}).
\begin{figure}
	\centering
	\includegraphics[width=0.6\textwidth]{SubjectCD}
	\caption{Inheritance diagram of the InformationSubject class}
	\label{fig:subjectCD}
\end{figure}
\textit{Subjects} also have a \verb|Mutation| object attached that is responsible for decaying the accuracy of the \textit{subject}. I give a detailed explanation of mutations in Section~\ref{section:mutation}.
\subsection{Adjectives}
An \textit{adjective} represents a detail or characteristic of a \textit{subject's} state. They can be arbitrarily defined by a developer. They represent the properties of a \textit{subject}. \textit{Adjectives} are instances of the \verb|InformationAdjective| class (Figure~\ref{fig:adjectiveCD}). In the \textit{Information Model}, there are two differentiable types of \verb|InformationAdjective| objects:
\begin{itemize}
	\item \verb|InformationProperty|: Represents factual information about a \textit{subject}. For example, "\textit{Agent} \verb|IS| \textit{alive}." is a factual piece of information that can either be true or false.
	\item \verb|InformationOpinion|: Represents statements about a \textit{subject's} state that are influenced by an information holder's relationship to the \textit{subject}. For example, the statement "\textit{Agent} \verb|IS| \textit{dangerous}." can be true for one agent but false for another.
\end{itemize}
This distinction is introduced so that conceptually there can be a difference between facts and opinions that someone has about any \textit{subject}.\\
An \verb|InformationAdjective| consists of the textual \textit{Characteristic} and a list of \textit{contradictions}. The contradictions are other \textit{adjectives} that conflict with the \textit{adjective} they are attached to. A simple example would be the two information statements  "\textit{Agent} \verb|IS| \textit{alive}." and  "\textit{Agent} \verb|IS| \textit{dead}.". Both cannot be true at the same time. Therefore, each \textit{adjective's} contradictions list contains the respective other. When an agent learns a piece of new information that contains an \textit{adjective}, they check the \textit{adjective's} contradictions and resolve any conflicts.\\
At the start of the game, an initial list of \textit{adjectives} that exist in the world is created. After that, the contradictions lists are created and attached to each \textit{adjective}.
\begin{figure}
	\centering
	\includegraphics[width=0.8\textwidth]{AdjectiveCD}
	\caption{Inheritance diagram of the InformationAdjective class}
	\label{fig:adjectiveCD}
\end{figure}
\subsection{Locations}
As mentioned before, a \textit{location} is a special kind of \textit{object} for the \verb|AT| information type. In a 3D game world that is driven by a multi-agent system, agents need to move around. For that, the \verb|InformationLocation| class attaches a position in the world to the information so that agents can retrieve an actual location from the information statement.\\
A \textit{location} also has a \verb|Mutation| object attached to it, so its accuracy can be reduced. Other than that, the \verb|InformationLocation| has only a textual name and the 3D position as a public interface.
\begin{figure}
	\centering
	\includegraphics[width=0.6\textwidth]{LocationCD}
	\caption{Inheritance diagram of the InformationLocation class}
	\label{fig:locationCD}
\end{figure}
\subsection{Mutation}
\label{section:mutation}
To simulate the decay of information and agents forgetting details, the \textit{Information Model} implements a \textit{Mutation} functionality. \verb|InformationSubject| and \verb|InformationLocation| objects have an object of the \verb|Mutation| class. These represent a hierarchy of less precise information values. Every \verb|Mutation| object has a reference \verb|ParentMutation| that points to a \verb|Mutation| object that holds the next less precise information value.\\
As an example, we assume the \verb|InformationLocation| $l$ with the name value "\textit{Village Square}". The \verb|Mutation| object can point to a less precise information value "\textit{Village}", which in turn points to an information value "\textit{Somewhere in the South}". This way, when $l$ is mutated once, its name value will be "\textit{Village}" and, if mutated again, will decay to "\textit{Somewhere in the South}" where it will remain.\\
This mechanic allows for agents to slowly forget about details in their information statements which makes the collection of memories more chaotic over time.\\
The values for the mutation hierarchy are set by the developer before the game starts.\\
The \verb|Mutate| function in the \verb|Information| class that is provided by the \verb|IMutatable| interface triggers the mutation of any of its statements' components.
\section{Agents}
In any multi-agent system, the central component is, of course, the agents. In the prototype game, those agents represent the NPCs who live in the game world or the player (Figure~\ref{fig:agentCD}). The only difference is that the player agent is controlled by the player instead of the game. However, for the NPCs, there is no difference between the player agent or any other NPC. In the following, I will generally talk about NPCs as agents for a better understanding of the conceptual implications in a multi-agent system. Agents move around in the world to perform actions, exchange information, and change their state depending on what they learn.
\begin{figure}
	\centering
	\includegraphics[width=0.6\textwidth]{AgentCD}
	\caption{Inheritance diagram of the Agent class}
	\label{fig:agentCD}
\end{figure}
The \verb|WorldObject| class is the parent class for both \verb|Agent| and \verb|Item| classes. It represents physical entities that exist as part of the multi-agent system. \verb|WorldObject| itself is a child class of Unity's \verb|MonoBehaviour| class which is the base class of all game objects managed by the Unity engine.\\
All \verb|Agent| instances inherit the members of their parent classes and thus have a textual identifier \textit{Name}, a \textit{Location} to denote the object's current location, exposed properties to set up the \textit{InformationSubject}, and an integer value \textit{WorldImportance}. This value is essential for the information heuristic for believability which is described in Section~\ref{section:heuristic}.\\
\textit{WorldImportance} indicates the initial interest a piece of information gets through the involved object. This interest can be positive or negative. A piece of information about the castle might have high positive value since the castle is an important place in the kingdom. Information about an enemy bandit, however, will have a negative number, as people are afraid of the bandits. These values should be an objective measure of an object's interest value. Subjective views from the agents are taken into account when the heuristic is calculated.\\
The critical properties of the \verb|Agent| class are the \textit{Inventory} which stores items in the agent's possession, \textit{Acquaintances} containing other agents that have interacted with it, \textit{ImportantPeople} are agents that have a close relationship with the object like friends or loved ones and \textit{Quests} which is a list of objectives the agent has. Through the \textit{ImportantPeople} property, specific agents can be treated differently and more favorably than others. This allows the introduction of a social network component into the multi-agent system.\\
The boolean values \textit{IsSeeing} and \textit{IsHearing} allow the determination what kind of information the agent is able to "sense" respectively.\\
The heart of the game mechanic is the \textit{Memory} property. It is an \verb|InformationManager| object. As the name implies, it stores, processes, and manages all the incoming pieces of information.\\
The different actions an agent can execute are also defined here. This includes interacting with other agents, picking up and dropping items, or attacking agents.
\subsection{NPC}
The \verb|NPC| class is a child class of the \verb|Agent| class and defines additional properties and functions that are unique only for NPCs.\\
This includes a \textit{Routine} property which is a list of behaviors the agent will execute one after another to simulate a daily life of a human. When they reach the end of their routine, they will start again from the beginning.
\subsection{Player}
In the scope of this thesis, the \verb|Player| class behaves very similarly to other agents. It has components attached that enable input to control the player agent. It needs its own class so that developers can differentiate between NPCs and the player. This is necessary as the agents might need to behave differently when interacting with the player agent to expose more information to the actual player in front of the screen. For example, when a dialogue is started, an NPC will not simply send information and continue with its routine, but it will pause, and the dialogue interface will be opened where the information exchanged is controlled by the player.
\subsection{Behavior}
In order for the intelligent agents to move, interact and follow their objectives, I defined multiple behaviors that allow them to perform actions (Figure~\ref{fig:behaviorCD}). The following behavior classes exist:
\begin{itemize}
	\item \verb|ExchangeInformationBehavior|: This behavior allows two agents to engage in an exchange of a piece of information. They choose which information to send each other based on the information heuristic.
	\item \verb|SendInformationBehavior|: As a child class of \verb|ExchangeInformationBehavior|, this behavior selects a random agent from the list of \textit{ImprotantPeople} and sends them a piece of information also based on the information heuristic. This behavior can be interpreted as "sending a message" to a distant friend. I implemented this so that information would also reach farther parts of the world eventually.
	\item \verb|WalkBehavior|: This simply allows the agent to move to a specified location in the world.
	\item \verb|TalkBehavor|: This would allow NPCs to stop the player and engage in a conversation with them. In the prototype game, this behavior is never used, and it is only the player who can initiate a conversation.
	\item \verb|WaitBehavior|: To simulate NPCs that are waiting or "doing nothing" for a specified time, I implemented this behavior. It is mainly to make the simulated behavior look more realistic and have NPCs stand in a place for a while.
	\item \verb|PickUpBehavior| and \verb|DropBehavior|: These two are implemented to let NPCs pick up a specified item in the vicinity or drop it in front of them, respectively.
\end{itemize}
\begin{figure}
	\centering
	\includegraphics[width=1.2\textwidth]{BehaviorCD}
	\caption{Inheritance diagram of the AgentBehavior class}
	\label{fig:behaviorCD}
\end{figure}
The parent \verb|AgentBehavior| class is an abstract class and declares functions for starting, interrupting, and resuming a behavior. Additionally, it declares the function \verb|IsBehaviorFinished| to check if the behavior is completed. This simple setup of behavior allows for easy extension of the capabilities of agents.
\subsection{Information Manager}
At the heart of the agents' logic is the \verb|InformationManager| class. It provides all the necessary functions to add, manage and process incoming \verb|Information| objects for an agent. Its main tasks are adding new pieces of information to the memory and evaluating them on a regular basis to update the information heuristic values and the trust values of an agent's known associates.\\
It manages the different pieces of information with lists of \verb|InformationContext| objects. Those are objects that pack an \verb|Information| object with contextual data about how the information and how it was received. The context object stores how many times the information was received already by distinct other agents, whom it was received from, the time since it was last received, and current values for believability and information heuristic. This additional contextual data is used by the \textit{Information Manager} to calculate current heuristic, believability, and trust values.\\
\\\\
The \textit{Information Manager} provides two lists of \verb|InformationContext| objects to manage its memories:
\begin{itemize}
	\item \textit{Speculative Memory}: the speculative memory stores every piece of information that an agent receives. It is a list of unconfirmed information that needs to be evaluated before it can be trusted. Only information that the agent did not perceive itself but was given by others is considered speculative.
	\item \textit{Stable Memory}: confirmed or trusted information is stored in the stable memory. Everything an agent learns by its own senses, like seeing, hearing, or otherwise witnessing, goes directly to the stable memory. If information is received via another agent, it needs to be verified through believability before it is transferred from the speculative memory to the stable memory. When an agent evaluates the information stored in its memory, it also updates believability values for every piece of information. This value is closely tied to the information heuristic. If the believability of information is above a certain threshold, it is transferred to the stable memory, and if it falls under the threshold, it is sent back to the speculative memory.
\end{itemize}
This structure of speculative and stable memory is taken from high availability backup systems. A process called chain replication uses a similar technique, where any change to the system is put into a speculative history until all nodes in the backup change have confirmed it. After that, it is transferred through all nodes again but in a stable history. When all nodes have confirmed the change in the stable history, the update was successful.~\cite{Van2004}\\
Although agents are only a single node, I tried to replicate this confirmation methodology with speculative and stable memories.
\section{Game World}
The agents in the prototype game live in an environment. The environment in the prototype game is \textit{inaccessible}, \textit{deterministic}, \textit{static}, and \textit{discrete}. It is inaccessible because agent learn of changes in the environment state only when they perceive or receive information about them, not as they happen. It is deterministic because every change an agent performs on the environment's state is known beforehand. The environment is static because the topology and structure do not change in this prototype, and it is discrete because the space agents can move in is limited.\\
In the prototype game, the environment for the multi-agent system is the game world. I created a 3D world that contains interesting and memorable locations that agents can move around in. I recreated a small kingdom with several settlements where different agents live and go about their day. The key locations are \textit{the village}, \textit{the castle}, \textit{the sawmill}, \textit{the forest}, \textit{the lake}, \textit{the farm}, and \textit{the enemy camp}~\ref{fig:gameWorld}.
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{GameWorld}
	\caption{An overview of the game world.}
	\label{fig:gameWorld}
\end{figure}
The landscape is filled with paths and landmarks to make orientation easier and guide the player between the locations.\\
I chose a medieval kingdom for my environment since it is a well-understood and established context for video game worlds. Ford, in his work about medieval towns in single-player games, describes how the boundaries between village and nature are also boundaries between the home and the frontier, the old and the new, the familiar and the unknown. This does not only relate to classic narratives about heroes venturing out into the wild but also says interesting things about this dichotomy in game worlds. Video games often contextualize towns and nature through their mechanics. There are games, for example, where you cannot use your weapons while inside a town or city. They also very often serve as quest hubs or quest destinations. This means that the borders define on a mechanical level what the player is allowed to do. Much like with real-world definitions of borders, this might say more about the player and their position in the game world than it does about the city or town itself.~\cite{Ford2019}
\section{Gameplay}
I have touched previously upon what the player interactions are that form the gameplay of the prototype game. Players control a knight in the kingdom who sets out to go on quests and adventures in the kingdom (Figure~\ref{fig:gameplay}). The player controls the movement of the knight and can talk to NPCs and interact with key items. If the player picks up a weapon, the character is able to attack other agents.\\
The novel game mechanic this prototype now presents, and that is the topic of this thesis, is more about the \textit{How} than the \textit{What}. Initially, the player character is given a quest to return the king back to the castle. That is all the information the player is given who is now free to roam the game world to try and reach this goal.\\
Through talking to NPCs and learning new information about the world, the player can find clues that help them reach their goal. Where exactly is the king? Is he guarded by a monster? How can I defeat the monster? NPCs can give pieces of information that let the player step by step deduce an answer to this question.\\
Alternatively the player can go a completely different route. By talking to NPCs, they can introduce new or even wrong pieces of information into the world. Could I convince enough people that I am the king? If someone would tell the queen, would she believe I am the king? Moreover, would that allow me to go back to the castle and thus achieve the goal?\\
The systems that I have created for this prototype allow for varied and interesting solutions to quests, even for the little amount of content that is in the prototype.
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{Gameplay}
	\caption{A sample gameplay scene.}
	\label{fig:gameplay}
\end{figure}
\section{Dialogue}
The primary way to purposely learn and give out information in the game is to talk to NPCs. For that, I have created a dialogue system that lets you either receive a piece of random information from an NPC, ask a specific question, or make a  statement on your own.\\
I used Yarn Spinner from Secret Lab to create the dialogue~\cite{Secret2021}. It is a lightweight tool that comes with a Unity plug-in and allows for branching node-based dialogue, and supports variables and simple logic in its dialogue files.\\
Yarn Spinner comes with an editor that easily allows developers to set up and write complex and branching dialogue files.
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{Yarn}
	\caption{The NPC Yarn dialogue file}
	\label{fig:yarn}
\end{figure}
\subsection{Questions}
Allowing the player to ask questions about specific game objects is much more goal-oriented than randomly hoping for helpful information to reach the player. The dialogue interface allows the player to create questions from a question verb, an information verb, and an object(Figure~\ref{fig:question}). The question verbs \textit{Who}, \textit{What}, \textit{Where}, and \textit{How} indicate whether the expected answer will be an NPC name, an item, a location, or an adjective. The question object contains options depending on the selection of the question verb and information verb. If the NPC has a piece of information that matches the question requirements, it will tell it to the player.
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{Question}
	\caption{Posing a statement to an NPC.}
	\label{fig:question}
\end{figure}
\subsection{Statements}
This allows the player to create new information based on objects they have encountered while playing. In the dialogue interface, the player can create information statements like they are defined in the \textit{Information Model}(Figure~\ref{fig:statement}). The selected verb will define what options are available for the information subject and information object. The available subjects and objects depend on the NPCs, items, and locations the player has encountered so far. Only adjectives are universally known by all agents as they do not represent things in the world but rather concepts.\\
If the information statement is well-formed according to the \textit{Information Model}, the newly created information will be transmitted to the NPC as if any other agent would have told to it.\\
The functionality to create any information from known components creates the ability to lie for the player, which creates exciting gameplay implications.
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{Statement}
	\caption{Asking a question to an NPC.}
	\label{fig:statement}
\end{figure}
\section{Inference}
To simulate the flow and creation of information more realistically in the NPCs, they can also deduce new Information from the ones they have. These deductions are based on rules that are globally defined and represent a form of cohesive causal understanding of the game world. To define such rules, there is the \verb|InferenceRule| class. It consists of a \verb|BoolExpression| object that defines the rule and a list of \verb|Information| objects that define the consequences or outcomes if the rule applies.\\
The \verb|BoolExpression| object holds \verb|Information| objects and is chained together with other \verb|BoolExpression| objects by logical operators to create the rule. Listing~\ref{listing:rule} defines the following rule for any agent $X$:
\begin{center}
	\textit{isArmed}$(X) \wedge $ \textit{isEnemy}$(X) \Rightarrow $ \textit{isDangerous}$(X)$ 
\end{center}
\begin{lstlisting}[
	caption={Creating an inference rule with consequences},
	label={listing:rule}
	]
	var rule = new InferenceRule(new BoolExpression(new Information(_player, WorldAdjectives[Adjectives.Armed]))).And(new BoolExpression(new Information(_player, WorldAdjectives[Adjectives.Enemy])));

	rule.Consequences = new List<Information> { new Information(_player, WorldAdjectives[Adjectives.Dangerous]) };
\end{lstlisting}
The variable \verb|_player| in the statement is just a placeholder and is replaced with different subjects during the evaluation of the rule. For the scope of this thesis, it made only sense to substitute for information subjects since the \textit{Information Model} is structured in such a way that the information statements say something about an information subject.\\
In order to evaluate such a rule, every agent has an \textit{Inference Engine} that allows them to do so. The \textit{Inference Engine} sees the agent's stable memories as its knowledge base. It goes through the rules and checks if the knowledge base of the agent satisfies the rule. If so, all the pieces of information that are defined in a rules' list of consequences are added to the stable memory of the agent(Listing~\ref{listing:evaluate}). This is repeated until no new information is added since any new information could trigger another rule.\\
The \verb|SatisfiesKnowledgeBase| function recursively checks if a rule's \textit{Boolean Expression} applies to the agent's memories. An information's subject is selected as a candidate if the information matches the information in the \textit{Boolean Expression} in all components except for the subject.
\begin{lstlisting}[
	caption={Evaluating inference rules},
	label={listing:evaluate}
	]
	public void Evaluate(){
		foreach (InferenceRule rule in Rules){
			List<InformationSubject> candidates = SatisfiesKnowledgeBase(rule.Expression, new List<InformationSubject>());
			
			if (!rule.AppliesToSelf)
				candidates.Remove(KnowledgeBase.Owner.InformationSubject);
			
			if (candidates.Any()){
				candidates.ForEach(c =>{
					rule.Consequences.ForEach(r =>{
						r = new Information(c, r);
						KnowledgeBase.TryAddNewInformation(r, KnowledgeBase.Owner);
					});
				});
				Evaluate();
			}
		}
	}
\end{lstlisting}
This way, agents can "reflect" on what they know and deduce new information.
\section{Heuristic}
\label{section:heuristic}
Each agent is able to subjectively evaluate the believability of pieces of information it has stored in its memory. A metric is needed to measure the believability of information. I approached this via the "interest" of information. This means how unique a piece of information is or how probable is it that a piece of given information could be authentic. This depends on the "interest" of the involved information components. The information "\textit{Farmer} \verb|HAS| \textit{milk}" is much more probable or uninteresting" than the information "\textit{The king} \verb|HAS| \textit{the magical sword}". So by evaluating the components of the information and their relation to one another, a value for the "interestingness" of information is calculated. I call this value \textit{Information Heuristic}.\\
The calculations for the \textit{Information Heuristic} are, of course, slightly different depending on the types of the involved information components. The general idea is that the more "interesting" a piece of information is, the higher its \textit{Information Heuristic} is. To make this value subjective to the agent, values that depend on the agent's experience or relation to involved agents are taken into consideration.\\
The basic formula is as follows:
\begin{equation}
	h' = h\ h^{v}\ b\ n_i\sum_{a \in K}trust(a)
\end{equation}
with $K \coloneqq \{A \cap I\}$, where $A$ is the set of known associates of the agent, and $I$ is the set of agents this information was previously received from.\\
The value $h^{v}$ is the part of the heuristic that is dependent on the verb and the information components, $b$ is the previous believability of the information, and $n_i$ is the number of times this information has already been received.\\
In other words, an information's heuristic is the product of itself with the component-dependent heuristic, the believability, the number of times it has been received, and the sum of the trust values of known agents this information has been received from. \\
In other words, an information’s heuristic is the product of itself with the component-dependent heuristic, the believability, the number of times it has been received, and the sum of the trust values of known agents this information has been received from.\\
Now the component-dependent heuristic is another heavy calculation function. It differentiates between the verb and then, in each case, calculates the value differently depending on the components. If another agent is involved, for example, the distance or degrees of separation between the bespoke agent and the receiver of the information is taken into account. The calculation is done using a \textit{breadth-first search}. Breadth-first search is an algorithm to search finite graphs. One of its advantages over for example depth-first search, is that it can be used to find the shortest path between two nodes $u$ and $v$, with the path length measured in the number of edges between the nodes~\cite{Bundy1984}. This should reflect cases where information is received like "I heard from a friend of a friend...". The longer the distance, the less trustworthy the information. If the subject is a known associate, then the trust the agent has towards the subject is also considered. The number of other pieces of information the receiver has concerning the subject is also used. This should reflect a familiarity with the subject.\\
If the subject of the information is an item, then not only is the uniqueness of the item in the world relevant, but also how unique the item is for the agent. This takes into account whether the agent owns an item of the same type and how many other pieces of information it has that refer to an item of the same type. This again is to simulate how familiar the agent is with the bespoke item.\\
So now there is a value for every information an agent has that says how "interesting" or "probable" that information is. To calculate the believability of information, this heuristic is now put into context with every other information an agent has. I define the \textit{distance} between two pieces of information as the absolute difference between their heuristic values.\\
For the believability $b$ of a piece of information this results in:
\begin{equation}
	b = \frac{\sum_{i,j \in M, i \neq j} h(i)-h(j)}{n}
\end{equation}
In this formula, $n$ is the size of the stable memory, and $M$ is the stable memory itself. The function $h$ is the heuristic function. This means the believability of information is the average distance to every other information in the stable memory.\\
Since this is calculated for every information in the stable memory of every agent, this operation needs a lot of processing power. I implemented the MapReduce programming model to enable the distribution of these calculations. The prototype does not leverage the distribution itself since this was too big a task for the scope of the thesis, but the implementation is prepared to be used with little additional work (Listing~\ref{listing:map}). The \textit{Map} and \textit{Reduce} steps are marked with comments in the listing.
\begin{lstlisting}[
	caption={The MapReduce implementation for calculating believability},
	label={listing:map}
	]
public void UpdateBelievability(){
	List<InformationContext> data = GetAllMemories();
	
	// Map
	var distances = new List<List<float>>();
	
	for (int i = 0; i < data.Count; i++){
		distances.Add(new List<float>());
		for (int k = 0; k < data.Count; k++){
			Information i1 = data[i].Information;
			Information i2 = data[k].Information;
			if (!i1.Equals(i2))
				distances[i].Add(GetInformationDistance(i1, i2));
		}
	}
	
	// Reduce
	for (int i = 0; i < distances.Count; i++){
		if (ContainsStableInformation(data[i].Information) && distances[i].Any())
			GetStableMemory(data[i].Information).Believability = distances[i].Average();
		else if (ContainsSpeculativeInformation(data[i].Information) && distances[i].Any())
			GetSpeculativeMemory(data[i].Information).Believability = distances[i].Average();
	}
}
\end{lstlisting}
Just how expensive the call to the \verb|UpdateBelievability| function is can be measured with Unity's \textit{Profiler}. It is a tool that allows exact time measurements of the different function calls in the Unity engine (Figure~\ref{fig:profiler}). The blue spikes in Figure~\ref{fig:frame} show spikes in the calculation times when the function is called.
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{Profiler}
	\caption{Frame data of the UpdateBelievability function call.}
	\label{fig:profiler}
\end{figure}
The frame data was captured about two minutes after the game started. By this time, all the agents had moved around for a while and learned new information. The function call takes 92ms. Almost a second of calculation time is an immense performance issue.
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{Frame}
	\caption{UpdateBelievability function call time.}
	\label{fig:frame}
\end{figure}
The function call is also perceivable in the game as there is a noticeable frame drop when the believability is calculated. This shows that distributing the call by truly applying the MapReduce model and using multiple nodes to calculate the believability would be a worthwhile adaption of the prototype. The amount of time this takes is not that important if it does not halt the game. A a simulation of the human process of "reflecting on one's thoughts" is something that could actually profit from a little waiting time.
\section{Consensus}
The prototype game differs from traditional multi-agent or even distributed systems in some significant ways. There are different requirements for it, and to a degree, it is even expected to behave differently.\\
For one, the system described in this thesis is not required to be concurrent from a conceptual point of view. It is not necessary that it responds as instantaneously as possible. As mentioned before, in fact,  it might serve the simulation if specific processes take some time because they should simulate human thought processes. Concurrency is essential nonetheless to prevent performance issues when calling CPU-intensive functions.\\
Availability is a different issue than for conventional distributed systems since the game is not accessed remotely. Of course, if parts of the system were to be distributed, accessibility for those would need to be as high as possible.\\
Fault tolerance is, of course, necessary for any software system. In the specific case of this game mechanic, it is again desired behavior to allow for some loopholes that can be exploited by the agents. The game mechanic enables the player to do so by letting them introduce arbitrary and potentially factual wrong information into the system.\\
Sending messages in the game takes a relatively long amount of time. This is deliberate to simulate human "word of mouth" behavior. Humans cannot instantly transfer thoughts. This is why reaching actual consensus is such a problem for this system and not even the end goal.\\
To consider the consensus problem for the game is still a practical examination of how communication works between intelligent agents. It is true that the system should be exploitable by the player, but at the same time, the goal of the simulation is to mimic human communication, which means some form of authentication should be present as humans will not accept anything they hear.\\
The game mechanics achieves this by applying the \textit{proof of personhood} method for permissionless consensus. Although the applications for actual consensus-reliant systems should be designed to allow \textit{only} humans to validate their system changes, the principal idea is beneficial even for the simulation of human behavior.\\
In the prototype game, agents are verified by their peers based on their \textit{trust} value. The trust value is dependent on the believability of the pieces of information an agent sends out(Listing~\ref{listing:trust}). If a piece of information is not very believable, trust decreases and vice versa.
\begin{lstlisting}[
caption={Calculating trust for proof of personhood},
label={listing:trust}
]
float believability = _stableMemory[idx].Believability;
if(Owner.Equals(sender))
	Owner.Acquaintances[sender] = 1.0f;
else
	Owner.Acquaintances[sender] += believability / 10.0f;
\end{lstlisting}
For a received information at position \verb|idx| of the list \verb|_stableMemory|, the trust value is defined as:
\begin{equation}
t' = t + \frac{believability}{10}
\end{equation}
A small fraction of the believability is added to the former trust value $t$. Since believability can be negative and positive, and trust can likewise decrease or increase. The fraction enforces more minor changes and not too drastic fluctuations in the trust values. If the sender of the information is the receiver, then the trust value is set to $1$ because every agent trusts itself completely.\\
The trust value of an agent then also influences the believability of the information. Of course, a more complex function for trust could be defined that takes strong relationships into account. For example, it could be more challenging for very trustworthy agents to lose trust and harder for untrustworthy ones to gain it. For the scope of this thesis, the present calculation is sufficient.\\
By influencing the result when receiving information, the trust value creates a metric for authenticating an agent when interacting with another agent. The authentication present in the prototype is only on a "one on one" basis that takes place at every information exchange. Agents do not authenticate themselves globally in the system, which is another big difference from conventional applications of consensus methods.\\
Back to the matter of consensus itself, I mentioned earlier that due to the time it takes for information to spread, it is unlikely that actual consensus among the agents is reached. That behavior, however, is beneficial to the simulation.\\
Another metric that is considered for the believability of information is how often it was received and how trustworthy those that it was received from are. This is actually a measurement that takes more than one agent into account and creates a weaker form of consensus while not communicating with many other agents. If information is received more often, agents assume that the probability of it being true is higher. Again this is an anchor to exploit the system to scatter wrong information and create lies that are advantageous to their playstyle. The quests in the prototype are designed to allow for different kinds of such playstyles.
\section{Quests}
To give the player an objective and an incentive to take action in this game, quests can be created. They have associated lists of information pieces and inference rules. For a quest to be completed, either the quest giver has to know about the required quest information, or the required inference rules have to satisfy the knowledge base of the quest giver.\\
That makes the quest state entirely subjective to the quest giver. Rather than being managed globally by a \textit{Game Manager}, the quest is solely dependent on the \textit{Information Manager} of the quest giver.\\
In the scope of the prototype game, I have created one quest that is available to complete. At the start of the game, when talking to the queen in the castle, she will task the player with returning the king to the castle (Figure~\ref{fig:quest}). This requirement can be created with one inference rule (Listing~\ref{listing:quest}).
\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{Quest}
	\caption{A quest is presented to the player.}
	\label{fig:quest}
\end{figure}
\begin{lstlisting}[
	caption={Creating an inference rule for a quest},
	label={listing:quest}
	]
	var rule = new InferenceRule(new BoolExpression(new Information(_player, WorldAdjectives[Adjectives.King]))).And(new BoolExpression(new Information(_player, GameObject.Find("Castle").GetComponent<Location>())));
	
	Quest q = new Quest(GameObject.Find("Queen").GetComponent<NPC>());
	q.GoalRules.Add(rule);
\end{lstlisting}
The rules simply define two requirements: Any character who \textit{is} the king and who is \textit{at} the castle, at the same time, will satisfy this rule. This creates \textit{objective-oriented} quests following Aarseth's classification~\cite{Aarseth2005}. There are only goal requirements that define the quest. All the steps to achieve this goal are up to the player. Combined with the dialogue system, however, this system also allows creating more controlled quests. Dialogue can play out differently based on variables that can be set depending on what the player does in the world. Additional inference rules could be added that cover different outcomes for the quest. Quest giver characters could then react differently to those outcomes. The quest system is flexible to allow varied gameplay approaches through defining only goal requirements but allowing developers to take a more narrated approach by providing additional story content for specific combinations of outcomes.
\section{Narrative}
With the presented game mechanic, there are numerous narrative implications that need to be addressed. I have described \textit{how} the quests provided in the prototype game are purely defined through their goals. They do not specify how exactly those goals have to be reached, although they could do so by adding more restrictions to the goal.\\
The intention of the game mechanic is that precisely through this careful definition of goals, player agency is increased because they are less restricted in their choice of actions to accomplish a given goal. By freeing up the options for players, the narrative structure of a quest can change drastically.\\
Going back to the quest present in the prototype, I described two possible approaches that are very different not only in the actions necessary to complete the quest but also in the stories that are told.\\
The first approach is more aligned with conventional role-playing quest lines. The player takes the role of the knight who is tasked to bring the king back to the castle safely. In the village near the castle, the player can talk to NPCs to learn pieces of information about the world. They can also ask specifically for the location of the king. The king is guarded by the dragon at the clearing in the northwest area of the kingdom. If the player manages to learn the king’s location from one of the NPCs, they can travel to that location and will find the dragon and the king. The king will tell the player that the dragon will not let him go, and the player needs a weapon in order to defeat the dragon. Many NPCs carry a sword, but they will not simply give it to the player. There is, however, a sword in the stone circle north of the village. Players can either learn of its existence from other NPCs or just stumble across it while exploring. Interacting with the sword will allow the player to carry it. Now the player can go back to the clearing to defeat the dragon. Upon doing so, the king will start walking back to the castle. He will tell the player that he will inform the queen of the player’s deeds once he arrives. The player can then go back to the castle and wait for the king's return. When the queen meets him, she will learn that the king is back at the castle, and the quest will be finished.\\
This storyline is familiar and straightforward. It has a clear beginning, middle, and end. The king has been kidnapped by a dragon, and a brave knight sets out to rescue him. To defeat the dragon, the knight needs to find a mighty sword to defeat the beast. The knight wanders the kingdom in search of this weapon until he reaches it. Now he can slay the dragon and thus save the king who reclaims his rightful throne.\\
The structure resembles the hero's journey as defined by Campbell~\cite{Campbell2008}. The hero experiences adventures, faces challenges and their world undergoes a change. In the presented story the challenges are defeating the dragon and obtaining a powerful weapon. The changed world is the recognition of their valiant actions and the return to a stable kingdom under the king's rule.\\
In the prototype, all the storytelling is done on a plot level, meaning through the events that are transpiring. Character-driven storytelling is much more complex to simulate without strongly scripting the dialogue. One step towards more character-driven stories would be by including the previously mentioned emotion engines to enable NPCs to simulate more human reactions to events. However, to articulate the characters’ feelings, the dialogue system still would need to be fundamentally reworked and or extended, which exceeds the scope of this thesis.\\
The second approach to complete the quest I presented is to convince enough people of the fact that the knight is the king. If an NPC with a high enough trust value tells this to the queen, she will believe that the knight is now the king, and since they are present at the castle, she will also learn the king is at the castle, which satisfies the quest objectives. This, albeit being a much shorter storyline, has more complex implications since it is not so aligned with narrative conventions players have learned to expect. Here we have a story of a cunning opportunist who wants to seize the power vacuum left by the absent king. The knight travels the kingdom and pronounces themself the new king. Through their sneaky deception of the people in the kingdom, word reaches the queen that the knight is the king. Since this is brought to her by a trusted soldier, she is led to believe that it must be the truth. So when the knight returns to her, she greets them as the new regent.\\
In that story, the player takes on the role of the villain, or at least an anti-hero, since their methods are not aligned with traditionally heroic values. It could be that the actual king is a tyrannical despot, which would make resorting to such measures more acceptable, or the queen could be part of the ruse to replace the king. This story is not structured differently than the first one and adds morally gray undertones to the player characters. The two storylines I have presented are both possible from the simple setup of the quest that is part of the prototype. The actions the player takes in the game are similar and mainly rely on the exchange of information, which is the heart of the game mechanic. Nevertheless, even though the quest is completed in both cases with the satisfaction of the goal conditions, the narrative implications of the two variants are fundamentally different both in their story structure and even in the story genre. Where the first story is a classic fantasy adventure story, the second is more a story of political deception.\\
Of course, all these potential elements of narrative framing are not part of the prototype. The present dialogue system would allow for reactions depending on the player's actions because the Yarn Spinner dialogue allows for the use of variables that can be tied to the gameplay events. Nevertheless, the use of game world information creates varied possibilities for completing objective-oriented quests that offer exciting story explanations.
